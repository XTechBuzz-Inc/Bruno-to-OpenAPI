#!/usr/bin/env node

const { Command } = require('commander');
const { convertBrunoToOpenApi } = require('../src/index');
const path = require('path');
const fs = require('fs-extra');

const program = new Command();

program
  .name('bruno-to-openapi')
  .description('Convert Bruno collection to OpenAPI specification')
  .version('0.1.0')
  .argument('<input>', 'Bruno collection directory path')
  .argument('[output]', 'Output file path for OpenAPI spec (JSON)', './openapi.json')
  .option('-v, --verbose', 'Enable verbose logging')
  .option('-f, --force', 'Overwrite output file if it exists')
  .option('--include-tags <tags>', 'Include only requests with these tags (comma-separated)', (value) => value.split(',').map(t => t.trim()).filter(t => t))
  .option('--exclude-tags <tags>', 'Exclude requests with these tags (comma-separated)', (value) => value.split(',').map(t => t.trim()).filter(t => t))
  .action(async (input, output, options) => {
    try {
      // Resolve paths
      const inputPath = path.resolve(process.cwd(), input);
      const outputPath = path.resolve(process.cwd(), output);

      // Check if input directory exists
      if (!await fs.pathExists(inputPath)) {
        console.error(`\n‚ùå Error: Input directory does not exist: ${inputPath}\n`);
        process.exit(1);
      }

      // Check if output file exists
      const outputExists = await fs.pathExists(outputPath);
      if (outputExists && !options.force) {
        console.error(`\n‚ùå Error: Output file already exists: ${outputPath}`);
        console.error('Use --force to overwrite, or choose a different output file.\n');
        process.exit(1);
      }

      // If force flag is set, remove existing file
      if (outputExists && options.force) {
        console.log(`üóëÔ∏è  Removing existing file: ${outputPath}\n`);
        await fs.remove(outputPath);
      }

      // Convert Bruno to OpenAPI
      const result = await convertBrunoToOpenApi(inputPath, outputPath, {
        verbose: options.verbose,
        includeTags: options.includeTags,
        excludeTags: options.excludeTags
      });

      // Print summary
      console.log('\nüìä Summary:');
      console.log(`   Collection: ${result.collectionName}`);
      console.log(`   Paths: ${result.pathCount}`);
      console.log(`   Operations: ${result.operationCount}`);
      if (result.totalRequests !== undefined && result.filteredRequests !== undefined) {
        if (result.totalRequests !== result.filteredRequests) {
          console.log(`   Requests: ${result.filteredRequests} of ${result.totalRequests} (filtered)`);
        } else {
          console.log(`   Requests: ${result.totalRequests}`);
        }
      }
      console.log(`   Output: ${result.outputPath}`);
      console.log('');

    } catch (error) {
      console.error(`\n‚ùå Error: ${error.message}\n`);
      if (options.verbose) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  });

program.parse();

